
#include "db.h"

EXEC SQL INCLUDE sqlca;

static DBSingleton *instancia = NULL;

DBSingleton *getInstance(void)
{
    if (instancia == NULL)
    {
        instancia = malloc(sizeof(DBSingleton));
        if (instancia != NULL)
        {
            EXEC SQL BEGIN DECLARE SECTION;
            char conn_str[MAX_LENGTH]; //Esto es para guardar la cadena de conexión lab02@127.0.0.1:5432
            char usuario[MAX_NOMBRE_LENGTH];
            EXEC SQL END DECLARE SECTION;

            //En los %s le pasamos los valores de las constantes definidas en constants.h y guardamos la cadena de conexión en conn_str
            snprintf(conn_str, sizeof(conn_str), "%s@%s:%s", DB_NAME, DB_IP, DB_PORT);
            strncpy(usuario, DB_USER, sizeof(usuario)); // Copiamos el nombre de usuario a la variable usuario
            printf(CHAR_DB_CONECTANDO, conn_str);


            EXEC SQL CONNECT TO :conn_str USER :usuario;

            if (sqlca.sqlcode != SQL_SUCCESS)
            {
                printf(CHAR_DB_ERROR, sqlca.sqlcode);
                free(instancia);
                instancia = NULL;
            }
            else
            {
                instancia->conectado = DB_CONECTADO;
                printf(CHAR_DB_EXITOSO);
            }
        }
    }
    return instancia;
}

void cerrar_conexion(void)
{
    if (instancia != NULL)
    {
        EXEC SQL DISCONNECT;
        free(instancia);
        instancia->conectado = DB_DESCONECTADO;
        instancia = NULL;
        
        printf(CHAR_DB_DESCONECTANDO);

    }
}

bool validarCapacidadParque(PARQUE parque, int mes,int dia, int cantidad)
{
    int totalReservas=getTotalReservasParque(parque.id_parque,mes,dia);
    if(totalReservas == ERROR_SIGNAL) {
        printf(ERROR_RESERVAS_PARQUE, sqlca.sqlcode);
        return false; // Error al obtener reservas
    }
    if(totalReservas + cantidad > parque.capacidad_maxima_diaria){
        return false;
    }
    return true;
}
bool validarCapacidadParking(PARQUE parque, int mes, int dia, int cantidad_vehiculos)
{
    PARKING parking=getParking(parque.id_parque);
    int totalReservasParking=getTotalReservasParking(parque.id_parque,parking.id_parking,mes,dia);
    if(parking.id_parking==ERROR_SIGNAL) return 0;
    if (totalReservasParking + cantidad_vehiculos > parking.limite_vehiculos)
    {
        printf(CHAR_CAPACIDAD_PARKING_EXCEDIDA, parking.id_parking, totalReservasParking, parking.limite_vehiculos);
        return false;
    }
    
    return true;
}
int getTotalReservasParking(int id_parque, int id_parking, int mes, int dia)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int total_reservas = 0;
    int id_parking_local = id_parking;
    int mes_local = mes;
    int dia_local = dia;
    int id_parque_local = id_parque;
    EXEC SQL END DECLARE SECTION;

    // Contar la cantidad de pases_parques que incluyen parking para ese parking y fecha
    EXEC SQL SELECT COUNT(*) INTO :total_reservas
        FROM pases_parques pp
        WHERE pp.incluye_parking = TRUE
          AND pp.id_parque = :id_parque_local
          AND EXTRACT(MONTH FROM pp.fecha_acceso) = :mes_local
          AND EXTRACT(DAY FROM pp.fecha_acceso) = :dia_local;

    if (sqlca.sqlcode != SQL_SUCCESS && sqlca.sqlcode != SQL_NO_DATA_FOUND) {
        printf("Error al obtener total de reservas de parking: %d\n", sqlca.sqlcode);
        return ERROR_SIGNAL;
    }
    if (sqlca.sqlcode == SQL_NO_DATA_FOUND) {
        printf(ERROR_CONTAR_RESERVAS_PARKING, id_parque_local, mes_local, dia_local);
        total_reservas = 0; // No hay reservas
    }
    else if (total_reservas < 0) {
        printf(ERROR_CONTAR_RESERVAS_PARKING, id_parque_local, mes_local, dia_local);
        return ERROR_SIGNAL; // señal de error
    }

    return total_reservas;
}
bool existeCiVisitante(const char *num)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char cedula[MAX_CI_LENGTH];
    bool existe;
    EXEC SQL END DECLARE SECTION;

    strncpy(cedula, num, sizeof(cedula));


    EXEC SQL SELECT EXISTS(SELECT 1 FROM visitantes WHERE ci = :cedula) INTO :existe;

    if (sqlca.sqlcode != SQL_SUCCESS && sqlca.sqlcode != SQL_NO_DATA_FOUND)
    {
        printf(ERROR_OBTENER_DATOS, sqlca.sqlcode);
        return false; // señal de error
    }

    if (sqlca.sqlcode == SQL_NO_DATA_FOUND)
    {
        printf(ERROR_INEXISTENTE_CI);
        existe = false; // No se encontró el visitante
    }
    else if (existe == 0)
    {
        printf(ERROR_INEXISTENTE_CI);
    }

    return existe;
}

VISITANTE getVisitante(const char *cedula)
{
    EXEC SQL BEGIN DECLARE SECTION;
    int id_visitante;
    char ci[MAX_CI_LENGTH];
    char nombre[MAX_NOMBRE_LENGTH];
    char cedula_local[MAX_CI_LENGTH];
    EXEC SQL END DECLARE SECTION;

    VISITANTE visitante;

    strncpy(cedula_local, cedula, sizeof(cedula_local));

    EXEC SQL SELECT id_visitante, ci, nombre INTO :id_visitante, :ci, :nombre FROM visitantes WHERE ci = :cedula_local;

    if (sqlca.sqlcode != SQL_SUCCESS && sqlca.sqlcode != SQL_NO_DATA_FOUND)
    {
        printf(ERROR_OBTENER_DATOS, sqlca.sqlcode);
        visitante.id_visitante = ERROR_SIGNAL; // señal de error
    }
    else if (sqlca.sqlcode == SQL_NO_DATA_FOUND)
    {
        visitante.id_visitante = ERROR_SIGNAL;
    }
    else
    {
        visitante.id_visitante = id_visitante;
        strncpy(visitante.ci, ci, sizeof(visitante.ci));
        visitante.ci[sizeof(visitante.ci) - 1] = '\0'; // Asegurar terminación nula
        strncpy(visitante.nombre, nombre, sizeof(visitante.nombre));
        visitante.nombre[sizeof(visitante.nombre) - 1] = '\0'; // Asegurar terminación nula
    }

    return visitante;
}

PARQUE getParque(int id){
    EXEC SQL BEGIN DECLARE SECTION;
    int id_parque_local=id;
    int id_parque;
    int id_ubicacion;
    char nombre[MAX_NOMBRE_LENGTH];
    int capacidad_maxima_diaria;
    EXEC SQL END DECLARE SECTION;

    PARQUE parque;

    printf("Buscando el parque con ID %d\n", id);
    EXEC SQL SELECT id_parque, id_ubicacion, nombre, capacidad_maxima_diaria 
    INTO :id_parque, :id_ubicacion, :nombre, :capacidad_maxima_diaria 
    FROM parques p
    WHERE p.id_parque=:id_parque_local;

    if (sqlca.sqlcode != SQL_SUCCESS && sqlca.sqlcode != SQL_NO_DATA_FOUND)
    {
        printf(ERROR_OBTENER_DATOS, sqlca.sqlcode);
        parque.id_parque = ERROR_SIGNAL; // señal de error
    }
    else if (sqlca.sqlcode == SQL_NO_DATA_FOUND)
    {
        printf(ERROR_PARQUE_NO_ENCONTRADO, id_parque);
        parque.id_parque = ERROR_SIGNAL;
    }
    else
    {
        parque.id_parque = id_parque;
        parque.id_ubicacion=id_ubicacion;
        parque.capacidad_maxima_diaria=capacidad_maxima_diaria;
        strncpy(parque.nombre, nombre, sizeof(parque.nombre));
    }
    return parque;
}

PARKING getParking(int id_parque){
    EXEC SQL BEGIN DECLARE SECTION;
        int id_parking;
        int id_parque_local=id_parque;
        int limite_vehiculos;
        int costo_adicional;
    EXEC SQL END DECLARE SECTION;
    PARKING parking;
    

    EXEC SQL SELECT id_parking, limite_vehiculos, costo_adicional 
    INTO :id_parking, :limite_vehiculos, :costo_adicional
    FROM parkings p
    WHERE p.id_parque=:id_parque_local;

    if (sqlca.sqlcode != SQL_SUCCESS && sqlca.sqlcode != SQL_NO_DATA_FOUND)
    {
        printf(ERROR_OBTENER_DATOS, sqlca.sqlcode);
        parking.id_parking = ERROR_SIGNAL; // señal de error
    }
    else if (sqlca.sqlcode == SQL_NO_DATA_FOUND)
    {
        printf(ERROR_NO_SE_ENCONTRO_PARKING, id_parque);
        parking.id_parking = ERROR_SIGNAL;
    }
    else
    {
        parking.id_parking = id_parking;
        parking.id_parque=id_parque;
        parking.limite_vehiculos=limite_vehiculos;
        parking.costo_adicional=costo_adicional;
    }
    return parking;
}
// int getTotalPasesVisitante(int id_visitante, int mes, int dia)
// {
//     EXEC SQL BEGIN DECLARE SECTION;
//     int total_pases = 0;
//     int id_visitante_local = id_visitante;
//     int mes_local = mes;
//     int dia_local = dia;
//     EXEC SQL END DECLARE SECTION;

//     printf("Obteniendo total de pases para visitante con ID: %d en fecha %d/%d...\n", id_visitante, mes, dia);
    
//     EXEC SQL SELECT COUNT(*) INTO :total_pases FROM pases WHERE id_visitante = :id_visitante_local;
//     if (sqlca.sqlcode != SQL_SUCCESS)
//     {
//         printf("Error al obtener total de pases: %d\n", sqlca.sqlcode);
//         return ERROR_SIGNAL; // señal de error
//     }

//     printf("Total de pases encontrados: %d\n", total_pases);
//     return total_pases;
// }

void imprimirPasesVisitantePorFecha(int id_visitante, int mes, int dia) {
    EXEC SQL BEGIN DECLARE SECTION;
    int id_visitante_local = id_visitante;
    int id_pase;
    int mes_local = mes;
    int dia_local = dia;
    char fecha_acceso[MAX_FECHA_LENGTH];// "YYYY-MM-DD"
    char nombre_parque[MAX_NOMBRE_LENGTH];
    EXEC SQL END DECLARE SECTION;

    EXEC SQL DECLARE cur_pase_fecha CURSOR FOR
        SELECT pp.id_pase, pp.fecha_acceso, pa.nombre
        FROM pases_parques pp
        JOIN pases p ON pp.id_pase = p.id_pase
        JOIN parques pa ON pp.id_parque = pa.id_parque
        WHERE p.id_visitante = :id_visitante_local
          AND EXTRACT(MONTH FROM pp.fecha_acceso) = :mes_local
          AND EXTRACT(DAY FROM pp.fecha_acceso) = :dia_local
        ORDER BY pp.fecha_acceso;

    EXEC SQL OPEN cur_pase_fecha;

    printf("buscando pases del visitante (ID: %d) para el día %d/%d...\n", id_visitante, dia, mes);
    printf("\nPases del visitante (ID: %d) para el día %d/%d:\n", id_visitante, dia, mes);
    printf("--------------------------------------------------\n");

    int encontrados = 0;

    while (1) {
        EXEC SQL FETCH cur_pase_fecha INTO :id_pase, :fecha_acceso, :nombre_parque;
        if (sqlca.sqlcode != SQL_SUCCESS) break;

        printf("Pase ID: %d | Fecha: %s | Parque: %s\n",id_pase,fecha_acceso,nombre_parque);
        encontrados++;
    }

    if (encontrados == 0) {
        printf("No se encontraron pases para esa fecha.\n");
    }

    EXEC SQL CLOSE cur_pase_fecha;
}

long getMontoTotal(int anio, int mes){
    EXEC SQL BEGIN DECLARE SECTION;
    long total=0;
    int anio_local=anio;
    int mes_local=mes;
    char fecha_compra[MAX_FECHA_LENGTH];
    EXEC SQL END DECLARE SECTION;
    
    EXEC SQL SELECT SUM(monto_total) INTO :total FROM compras c 
        WHERE EXTRACT(YEAR FROM c.fecha_compra) = :anio_local
        AND EXTRACT(MONTH FROM c.fecha_compra) = :mes_local;

    printf("Buscando total en el año %d, y el mes %d \n", anio_local, mes_local);

    return total;
 
}

int getTotalReservasParque(int id_parque, int mes, int dia){
    //Agarrar el TOTAL de reservas|pases_parques para ESE parque
    EXEC SQL BEGIN DECLARE SECTION;
    int total_pases;
    int id_parque_local=id_parque;
    int mes_local=mes;
    int dia_local=dia;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL SELECT COUNT(*) INTO :total_pases FROM pases_parques pp
        WHERE pp.id_parque=:id_parque_local
        AND EXTRACT(MONTH FROM pp.fecha_acceso) = :mes_local
        AND EXTRACT(DAY FROM pp.fecha_acceso) = :dia_local;
    if (sqlca.sqlcode != SQL_SUCCESS) {
        printf(ERROR_RESERVAS_PARQUE, sqlca.sqlcode);
        return ERROR_SIGNAL; // señal de error
    }
    return total_pases;
}

PARQUE * getParquesDisponibles()
{
    EXEC SQL BEGIN DECLARE SECTION;
    int id_parque;
    int id_ubicacion;
    char nombre[MAX_NOMBRE_LENGTH];
    int capacidad_maxima_diaria;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL DECLARE cursor_get_parques CURSOR FOR
        SELECT id_parque, id_ubicacion, nombre, capacidad_maxima_diaria FROM parques;

    EXEC SQL OPEN cursor_get_parques;

    PARQUE *parques = malloc(sizeof(PARQUE) * MAX_PARQUES);
    if (!parques) {
        printf(ERROR_ASIGNAR_MEMORIA);
        return NULL;
    }

    int index = 0;

    while (1) {
        EXEC SQL FETCH cursor_get_parques INTO :id_parque, :id_ubicacion, :nombre, :capacidad_maxima_diaria;

        if(sqlca.sqlcode != SQL_SUCCESS) {
            if (sqlca.sqlcode == SQL_NO_DATA_FOUND) {
                break; // Fin del cursor
            } else {
                printf(ERROR_OBTENER_DATOS, sqlca.sqlcode);
                free(parques);
                EXEC SQL CLOSE cursor_get_parques;
                return NULL; // señal de error
            }
        }
        if (index >= MAX_PARQUES) {
            printf(ERROR_MAXIMOS_PARQUES, MAX_PARQUES);
            break; // Evita desbordamiento de memoria
        }
        parques[index].id_parque = id_parque;
        parques[index].id_ubicacion = id_ubicacion;
        strncpy(parques[index].nombre, nombre, sizeof(parques[index].nombre));
        parques[index].capacidad_maxima_diaria = capacidad_maxima_diaria;
        index++;

    }
    EXEC SQL CLOSE cursor_get_parques;
    return parques;
}

int getMaxIdVisitante() {
    EXEC SQL BEGIN DECLARE SECTION;
    int max_id = 0;
    EXEC SQL END DECLARE SECTION;
    EXEC SQL SELECT MAX(id_visitante) INTO :max_id FROM visitantes;

    if (sqlca.sqlcode != SQL_SUCCESS) {
        printf(ERROR_OBTENER_MAX_ID, sqlca.sqlcode);
        return ERROR_SIGNAL; // señal de error
    }

    return max_id;
}
VISITANTE crearVisitante(const char *cedula, const char *nombre) {
    EXEC SQL BEGIN DECLARE SECTION;
    int id_visitante = getMaxIdVisitante() + 1; // Incrementar el ID máximo
    char ci[MAX_CI_LENGTH];
    char nombre_local[MAX_NOMBRE_LENGTH];
    EXEC SQL END DECLARE SECTION;

    VISITANTE visitante;

    strncpy(ci, cedula, sizeof(ci));
    strncpy(nombre_local, nombre, sizeof(nombre_local));

    EXEC SQL INSERT INTO visitantes (id_visitante, ci, nombre)
        VALUES (:id_visitante, :ci, :nombre_local);

    if (sqlca.sqlcode != SQL_SUCCESS) {
        printf(ERROR_OBTENER_DATOS, sqlca.sqlcode);
        EXEC SQL ROLLBACK;
        visitante.id_visitante = ERROR_SIGNAL; // señal de error
        return visitante;
    }

    visitante.id_visitante = id_visitante;
    strncpy(ci, cedula, sizeof(ci) - 1);
    ci[sizeof(ci) - 1] = '\0';

    strncpy(nombre_local, nombre, sizeof(nombre_local) - 1);
    nombre_local[sizeof(nombre_local) - 1] = '\0';

    EXEC SQL COMMIT;
    return visitante;
}

long getPrecio(int id_parque, int mes, int dia) {
    EXEC SQL BEGIN DECLARE SECTION;
    long precio = 0;
    int id_parque_local = id_parque;
    int mes_local = mes;
    int dia_local = dia;
    EXEC SQL END DECLARE SECTION;

    // Buscar el precio válido para la fecha dada (fecha_acceso debe estar entre fecha_inicio y fecha_fin)
    EXEC SQL SELECT precio INTO :precio FROM precios 
        WHERE id_parque = :id_parque_local
        AND EXTRACT(MONTH FROM fecha_inicio) <= :mes_local
        AND EXTRACT(MONTH FROM fecha_fin) >= :mes_local
        AND EXTRACT(DAY FROM fecha_inicio) <= :dia_local
        AND EXTRACT(DAY FROM fecha_fin) >= :dia_local;

    if (sqlca.sqlcode != SQL_SUCCESS) {
        printf(ERROR_OBTENER_DATOS, sqlca.sqlcode);
        return ERROR_SIGNAL; // señal de error
    }

    return precio;
}